<!DOCTYPE html>
<html>
<head>
<style>
canvas {padding: 30px}
</style>
<script src='js/three.js'></script>
<script src='js/XYZWRenderer.js'></script>
<script src='js/crates.js'></script>
<script src="js/OrbitControls.js"></script>
</head>
<body>
<h1>XYZW Club Software renderer test</h1>
<p>The same scene rendered with WebGL and with our software renderer respectively.  </p>
<p>I think we could learn a lot writing a renderer that matches the WebGL one.</p>
<script>
  var width = 400;
  var height = 400;

  var webgl_renderer  = new THREE.WebGLRenderer();
  webgl_renderer.setSize( width, height);
  document.body.appendChild( webgl_renderer.domElement );

  var canvas_renderer  = new XYZWRenderer();
  canvas_renderer.setSize( width, height);
  document.body.appendChild( canvas_renderer.domElement );

  var camera  = new THREE.PerspectiveCamera(45, width / height, 0.01, 1000);

  var start = function(scene) {

    console.log(scene);

    camera.aspect = 1.0;
    camera.near = 0.01;
    camera.far = 1000;
    camera.position.y = 170;
    camera.position.x = 600;
    camera.position.z = 1.7;
    camera.updateProjectionMatrix();

    var render_gl = function() {
        webgl_renderer.render(scene, camera);
    }

    var render_soft = function() {
        canvas_renderer.render(scene, camera);
    }

    var controls = new THREE.OrbitControls(camera, webgl_renderer.domElement);
    controls.addEventListener("change", render_gl);
    controls.addEventListener("end", render_soft);

    controls.rotateSpeed = 1.0;
		controls.zoomSpeed = 1.2;
		controls.panSpeed = 0.8;

    var animate = function() {
      requestAnimationFrame( animate );
      controls.update();
    };

    animate();
    render_gl();
    render_soft();
  };

  var addLight = function(scene) {
    scene.add( new THREE.AmbientLight(0x333333));
    var directionalLight = new THREE.DirectionalLight(0xeeeeee, 5);
    directionalLight.position.set(7, 20, 40).normalize();
    scene.add(directionalLight);
  };

  var makeMaterials = function() {
    return {
       "leaves": new THREE.MeshPhongMaterial( { color: 0x008800, specular: 0xffffff, shininess: 200 } ),
       "wood":   new THREE.MeshPhongMaterial( { color: 0x584000 } ),
       "bauble": new THREE.MeshPhongMaterial( { color: 0xff0000 } )
     };
  }

  function addFloor(scene) {
    var geometry = new THREE.BoxGeometry( 100, 100, 10 );
    var material = new THREE.MeshPhongMaterial( { color: 0x111111 } );
    var floor = new THREE.Mesh( geometry, material );
    floor.rotation.x = -Math.PI / 2.0;
    floor.position.y = -150;
    scene.add( floor );
  }

 function makeTree(materials, scene){
    var diameters = [20, 40, 60, 80, 95, 100, 90];
    var heights = [40, 50, 60, 70, 80, 90, 100];

    for (var index in diameters) {
      var d = diameters[index];
      var h = heights[index];
      var segment = new THREE.Mesh(new THREE.CylinderGeometry(1, d, h, 30, 1, false), materials["leaves"]);
      var position = 130 - (index * 25);
      segment.position.set(0, position, 0);
      scene.add(segment);

      var rotations = [1, 0, 0, -1, 1, 0];
      for (var i = 0; i < 4; i++) {
        var bauble = new THREE.Mesh(new THREE.SphereGeometry(5, 15,5), materials["bauble"]);
        bauble.position.set(d * rotations[i], position - h/2 - 5, d * rotations[i+2]);
        scene.add(bauble);
      }
    }

    var trunk = new THREE.Mesh(new THREE.CylinderGeometry(2, 20, 300, 30, 1, false), materials["wood"]);
    scene.add(trunk);
  }

  var scene = new THREE.Scene();
  addLight(scene);
  addFloor(scene);
  makeTree(makeMaterials(), scene);
  start(scene);

</script>

</body>
</html>
